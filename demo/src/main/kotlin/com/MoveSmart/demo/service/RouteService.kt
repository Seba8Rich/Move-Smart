package com.movesmart.demo.service

import com.movesmart.demo.dto.RouteDTORequest
import com.movesmart.demo.model.Route
import com.movesmart.demo.repository.BusRepository
import com.movesmart.demo.repository.RouteRepository
import jakarta.persistence.EntityManager
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional


@Service
@Transactional
class RouteService(
    private val routeRepository: RouteRepository,
    private val busRepository: BusRepository,
    private val entityManager: EntityManager
) {
    
    /**
     * Resets the PostgreSQL sequence for routes.id to start from the current max ID + 1
     * This ensures new routes get IDs starting from 1 (if table is empty) or continuing from max ID
     * Only resets if the sequence is ahead of the max ID
     */
    private fun resetSequenceIfNeeded() {
        try {
            // Get the current max ID from the routes table
            val maxIdQuery = "SELECT COALESCE(MAX(id), 0) FROM routes"
            val maxIdResult = entityManager.createNativeQuery(maxIdQuery).singleResult
            val maxId = (maxIdResult as? Number)?.toLong() ?: 0L
            
            // Get the sequence name
            val sequenceQuery = "SELECT pg_get_serial_sequence('routes', 'id')"
            val sequenceResult = entityManager.createNativeQuery(sequenceQuery).singleResult
            val sequenceName = sequenceResult?.toString()?.removeSurrounding("\"")?.removeSurrounding("'") ?: "routes_id_seq"
            
            // Get current sequence value
            val currentSeqQuery = "SELECT last_value FROM $sequenceName"
            val currentSeqResult = entityManager.createNativeQuery(currentSeqQuery).singleResult
            val currentSeqValue = (currentSeqResult as? Number)?.toLong() ?: 0L
            
            // Only reset if sequence is ahead of max ID
            val nextId = if (maxId > 0) maxId + 1 else 1
            if (currentSeqValue > nextId) {
                val resetQuery = "SELECT setval('$sequenceName', $nextId, false)"
                entityManager.createNativeQuery(resetQuery).executeUpdate()
            }
        } catch (ex: Exception) {
            // Log but don't fail - sequence reset is not critical
            println("Warning: Could not reset sequence: ${ex.message}")
        }
    }
    fun createRoute(request: RouteDTORequest): Route {
        // Validate and trim inputs
        val startStation = request.startStation.trim()
        val endStation = request.endStation.trim()
        
        if (startStation.isBlank()) {
            throw IllegalArgumentException("Start station cannot be empty")
        }
        if (endStation.isBlank()) {
            throw IllegalArgumentException("End station cannot be empty")
        }

        // Check if a route with the same startStation and endStation already exists
        val existingRoutes = routeRepository.findByStartStationAndEndStation(
            startStation = startStation,
            endStation = endStation
        )
        
        if (existingRoutes.isNotEmpty()) {
            throw IllegalArgumentException("A route with start station '$startStation' and end station '$endStation' already exists")
        }

        // If routeId is provided, check if it's already used by another route
        if (request.routeId != null) {
            val routeWithSameRouteId = routeRepository.findByRouteId(request.routeId)
            if (routeWithSameRouteId != null) {
                throw IllegalArgumentException("Route with routeId ${request.routeId} already exists")
            }
        }

        // Reset sequence to ensure IDs start from 1 or continue from max ID
        resetSequenceIfNeeded()
        
        // Create new route with auto-increment id and optional routeId
        // The id will be auto-generated by the database
        val route = Route(
            routeId = request.routeId, // User-defined display ID (optional)
            startStation = startStation,
            endStation = endStation,
            distanceKm = request.distanceKm,
            buses = mutableSetOf()
        )

        return routeRepository.save(route)
    }

    fun getAllRoutes(): List<Route> = routeRepository.findAll()
    
    fun getRouteById(id: Long): Route {
        return routeRepository.findById(id)
            .orElseThrow { IllegalArgumentException("Route not found with ID: $id") }
    }

    fun updateRoute(id: Long, request: RouteDTORequest): Route {
        val existingRoute = routeRepository.findById(id)
            .orElseThrow { IllegalArgumentException("Route not found with ID: $id") }
        
        // Validate and trim inputs
        val startStation = request.startStation.trim()
        val endStation = request.endStation.trim()
        
        if (startStation.isBlank()) {
            throw IllegalArgumentException("Start station cannot be empty")
        }
        if (endStation.isBlank()) {
            throw IllegalArgumentException("End station cannot be empty")
        }
        
        // Check if another route with the same startStation and endStation already exists
        // (excluding the current route being updated)
        val duplicateRoutes = routeRepository.findByStartStationAndEndStation(
            startStation = startStation,
            endStation = endStation
        )
        
        // Check if there's any duplicate route that's not the current one being updated
        val hasDuplicate = duplicateRoutes.any { it.id != existingRoute.id }
        if (hasDuplicate) {
            throw IllegalArgumentException("A route with start station '$startStation' and end station '$endStation' already exists")
        }
        
        // If routeId is being updated, check if it's already used by another route
        if (request.routeId != null && request.routeId != existingRoute.routeId) {
            val routeWithSameRouteId = routeRepository.findByRouteId(request.routeId)
            if (routeWithSameRouteId != null && routeWithSameRouteId.id != existingRoute.id) {
                throw IllegalArgumentException("Route with routeId ${request.routeId} already exists")
            }
        }
        
        // Update the route fields
        val updatedRoute = existingRoute.copy(
            routeId = request.routeId ?: existingRoute.routeId, // Update routeId if provided, otherwise keep existing
            startStation = startStation,
            endStation = endStation,
            distanceKm = request.distanceKm
        )
        
        return routeRepository.save(updatedRoute)
    }

    fun deleteRoute(id: Long): Boolean {
        return if (routeRepository.existsById(id)) {
            routeRepository.deleteById(id)
            true
        } else {
            false
        }
    }
}
